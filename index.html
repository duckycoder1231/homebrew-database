<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Homebrew ROM Database</title>
<style>
	/* ...existing code... */
	body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 20px; color: #111; }
	.container { max-width: 980px; margin: 0 auto; }
	header { display:flex; justify-content:space-between; align-items:center; gap:16px; margin-bottom:16px; }
	h1 { font-size:1.2rem; margin:0; }
	.controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
	input[type="search"], select, input[type="number"] { padding:6px 8px; border:1px solid #ccc; border-radius:6px; }
	button { padding:6px 10px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7; cursor:pointer; }
	.results { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:12px; }
	.card { border:1px solid #e0e0e0; padding:10px; border-radius:6px; background:#fff; }
	.meta { font-size:0.85rem; color:#555; margin-top:6px; }
	.small { font-size:0.85rem; color:#444; }
	.toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
	.form-inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
	textarea { width:100%; min-height:60px; padding:6px; border-radius:6px; border:1px solid #ccc; }
	.footer { margin-top:18px; color:#666; font-size:0.9rem; }
	.count { font-weight:600; }
	.hidden { display:none; }
</style>
</head>
<body>
<div class="container">
	<header>
		<h1>Homebrew ROM Database</h1>
		<div class="toolbar">
			<button id="exportBtn">Export JSON</button>
			<label style="display:inline-flex; gap:8px; align-items:center;">
				<input id="importFile" type="file" accept="application/json" class="hidden">
				<button id="importBtn">Import JSON</button>
			</label>
			<button id="resetBtn" title="Reset to sample data">Reset</button>
		</div>
	</header>

	<div class="controls">
		<input id="searchInput" type="search" placeholder="Search title, dev, description..." />
		<select id="consoleSelect"><option value="">All consoles</option></select>
		<input id="minYear" type="number" placeholder="Min year" style="width:110px" />
		<input id="maxYear" type="number" placeholder="Max year" style="width:110px" />
		<button id="clearFilters">Clear</button>
	</div>

	<div class="form-inline" style="margin-bottom:8px;">
		<button id="addToggle">Add entry</button>
		<span class="small">Results: <span id="resultCount" class="count">0</span></span>
	</div>

	<!-- Add a file input to the add form -->
	<form id="addForm" class="hidden" onsubmit="return false;">
		<div style="display:flex; gap:8px; flex-wrap:wrap;">
			<input id="title" placeholder="Title (required)" required>
			<input id="console" placeholder="Console (e.g., NES, Genesis) (required)" required>
			<input id="year" type="number" placeholder="Year (required)" style="width:110px" required>
			<input id="developer" placeholder="Developer" >
			<input id="downloadUrl" placeholder="Download URL (optional)" style="min-width:220px;">
			<!-- ROM file now required -->
			<label style="display:inline-flex; align-items:center; gap:8px;">
				<input id="romFile" type="file" accept=".nes,.sfc,.smc,.smd,.gb,.gbc,.gba,.bin,.iso,.zip" title="Upload ROM file (required)" required>
				<span class="small">ROM file (required)</span>
			</label>
		</div>
		<div style="margin-top:8px;">
			<textarea id="description" placeholder="Short description"></textarea>
		</div>
		<div style="margin-top:8px; display:flex; gap:8px;">
			<button id="addSave">Save</button>
			<button id="addCancel" type="button">Cancel</button>
		</div>
	</form>

	<section id="results" class="results" aria-live="polite"></section>

	<div class="footer">
		<p>Server-backed demo: entries are stored on the server. Use Export/Import to back up or migrate data.</p>
	</div>
</div>

<script>
	const API_BASE = ''; // same origin
	// element refs + filters
	const el = {
		search: document.getElementById('searchInput'),
		consoleSelect: document.getElementById('consoleSelect'),
		minYear: document.getElementById('minYear'),
		maxYear: document.getElementById('maxYear'),
		results: document.getElementById('results'),
		resultCount: document.getElementById('resultCount'),
		clearFilters: document.getElementById('clearFilters'),
		exportBtn: document.getElementById('exportBtn'),
		importBtn: document.getElementById('importBtn'),
		importFile: document.getElementById('importFile'),
		resetBtn: document.getElementById('resetBtn'),
		addToggle: document.getElementById('addToggle'),
		addForm: document.getElementById('addForm'),
		addSave: document.getElementById('addSave'),
		addCancel: document.getElementById('addCancel'),
		title: document.getElementById('title'),
		consoleInput: document.getElementById('console'),
		year: document.getElementById('year'),
		developer: document.getElementById('developer'),
		downloadUrl: document.getElementById('downloadUrl'),
		description: document.getElementById('description'),
		romFile: document.getElementById('romFile'),
		searchInput: document.getElementById('searchInput')
	};
	let db = []; // always fetched from server
	let filters = { q: '', console: '', minYear: null, maxYear: null };

	// fetch list from server (server supports filtering)
	async function fetchGames() {
		const params = new URLSearchParams();
		if (filters.q) params.set('q', filters.q);
		if (filters.console) params.set('console', filters.console);
		if (filters.minYear != null) params.set('minYear', String(filters.minYear));
		if (filters.maxYear != null) params.set('maxYear', String(filters.maxYear));
		const res = await fetch(API_BASE + '/api/games' + (params.toString() ? ('?' + params.toString()) : ''));
		if (!res.ok) { alert('Failed to fetch games'); return; }
		db = await res.json();
		applyAndRender();
	}

	function uniqueConsoles() {
		const set = new Set(db.map(x => x.console).filter(Boolean));
		return Array.from(set).sort();
	}

	// render uses server-provided metadata; file downloads use /api/games/:id/file
	function renderResults() {
		el.results.innerHTML = '';
		const filtered = db.slice().sort((a,b)=> (b.year||0)-(a.year||0));
		el.resultCount.textContent = filtered.length;
		if (!filtered.length) { el.results.innerHTML = '<div class="small">No results.</div>'; return; }
		filtered.forEach(it => {
			const div = document.createElement('div'); div.className = 'card';
			const downloadLink = it.fileName
				? `<a href="/api/games/${it.id}/file" download="${encodeURIComponent(it.fileName)}">Download</a>`
				: (it.downloadUrl ? `<a href="${escapeAttr(it.downloadUrl)}" target="_blank">Download</a>` : '');
			div.innerHTML = `
				<div><strong>${escapeHtml(it.title)}</strong></div>
				<div class="meta">${escapeHtml(it.console)} • ${it.year || 'n/a'} • ${escapeHtml(it.developer || '')}</div>
				<div class="small" style="margin-top:8px">${escapeHtml(it.description || '')}</div>
				<div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
					${downloadLink}
					<button data-id="${it.id}" class="delBtn">Delete</button>
				</div>
			`;
			el.results.appendChild(div);
		});
		// attach delete handlers
		document.querySelectorAll('.delBtn').forEach(b => {
			b.addEventListener('click', async ev => {
				const id = Number(ev.currentTarget.dataset.id);
				if (!confirm('Delete this entry?')) return;
				const res = await fetch(`/api/games/${id}`, { method: 'DELETE' });
				if (!res.ok) { alert('Delete failed'); return; }
				await fetchGames();
			});
		});
	}

	// utilities
	function escapeHtml(s = '') { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
	function escapeAttr(s=''){ return String(s).replace(/"/g, '%22'); }

	// event wiring (use server endpoints)
	let searchTimer = null;
	el.searchInput.addEventListener('input', () => {
		clearTimeout(searchTimer);
		searchTimer = setTimeout(()=>{ filters.q = el.searchInput.value; fetchGames(); }, 200);
	});
	el.consoleSelect.addEventListener('change', () => { filters.console = el.consoleSelect.value; fetchGames(); });
	el.minYear.addEventListener('change', () => { filters.minYear = el.minYear.value ? Number(el.minYear.value) : null; fetchGames(); });
	el.maxYear.addEventListener('change', () => { filters.maxYear = el.maxYear.value ? Number(el.maxYear.value) : null; fetchGames(); });
	el.clearFilters.addEventListener('click', () => {
		el.searchInput.value = ''; el.consoleSelect.value = ''; el.minYear.value = ''; el.maxYear.value = '';
		filters = { q: '', console: '', minYear: null, maxYear: null };
		fetchGames();
	});

	el.exportBtn.addEventListener('click', async () => {
		const res = await fetch('/api/games/export');
		if (!res.ok) { alert('Export failed'); return; }
		const blob = await res.blob();
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a'); a.href = url; a.download = 'homebrew_db.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	});

	// import JSON file -> POST /api/games/import
	el.importBtn.addEventListener('click', () => el.importFile.click());
	el.importFile.addEventListener('change', async (ev) => {
		const f = ev.target.files && ev.target.files[0];
		if (!f) return;
		try {
			const text = await f.text();
			const parsed = JSON.parse(text);
			if (!Array.isArray(parsed)) throw new Error('Invalid file format');
			const res = await fetch('/api/games/import', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(parsed) });
			if (!res.ok) throw new Error('Import failed');
			await fetchGames();
			alert('Imported ' + parsed.length + ' entries.');
		} catch (e) {
			alert('Import failed: ' + e.message);
		}
		ev.target.value = '';
	});

	el.resetBtn.addEventListener('click', async () => {
		if (!confirm('Reset server DB to sample dataset?')) return;
		const res = await fetch('/api/games/reset', { method: 'POST' });
		if (!res.ok) { alert('Reset failed'); return; }
		await fetchGames();
	});

	// Add form: POST /api/games with multipart form-data (rom file optional)
	el.addToggle.addEventListener('click', () => el.addForm.classList.toggle('hidden'));
	el.addCancel.addEventListener('click', () => el.addForm.classList.add('hidden'));
	el.addSave.addEventListener('click', async () => {
		const title = el.title.value.trim(); const c = el.consoleInput.value.trim();
		const y = Number(el.year.value);
		if (!title || !c || !Number.isFinite(y)) { alert('Please fill Title, Console and a numeric Year.'); return; }
		// require ROM file
		const file = el.romFile && el.romFile.files && el.romFile.files[0];
		if (!file) { alert('Please select a ROM file.'); return; }
		// simple client-side safety checks
		const MAX_SIZE = 200 * 1024 * 1024; // 200MB
		if (file.size > MAX_SIZE) { alert('ROM file too large (max 200MB).'); return; }
		const fd = new FormData();
		fd.set('title', title); fd.set('console', c); fd.set('year', String(y));
		fd.set('developer', el.developer.value.trim()); fd.set('description', el.description.value.trim()); fd.set('downloadUrl', el.downloadUrl.value.trim());
		fd.set('rom', file);
		el.addSave.disabled = true;
		try {
			const res = await fetch('/api/games', { method: 'POST', body: fd });
			if (!res.ok) {
				const body = await res.json().catch(()=>({ error: 'Upload failed' }));
				throw new Error(body && body.error ? body.error : 'Add failed');
			}
			el.addForm.reset(); el.addForm.classList.add('hidden');
			await fetchGames();
		} catch (err) {
			alert('Add failed: ' + err.message);
		} finally {
			el.addSave.disabled = false;
		}
	});

	function renderConsoleOptions() {
		const list = uniqueConsoles();
		el.consoleSelect.innerHTML = '<option value="">All consoles</option>';
		list.forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.textContent = c; el.consoleSelect.appendChild(opt); });
		const years = db.map(x => x.year).filter(y => Number.isFinite(y)); if (years.length) { el.minYear.placeholder = Math.min(...years); el.maxYear.placeholder = Math.max(...years); }
	}

	function applyAndRender() { renderConsoleOptions(); renderResults(); }

	// initial load
	fetchGames();
</script>
</body>
</html>