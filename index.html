<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Homebrew ROM Database</title>
<style>
	/* ...existing code... */
	body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 20px; color: #111; }
	.container { max-width: 980px; margin: 0 auto; }
	header { display:flex; justify-content:space-between; align-items:center; gap:16px; margin-bottom:16px; }
	h1 { font-size:1.2rem; margin:0; }
	.controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
	input[type="search"], select, input[type="number"] { padding:6px 8px; border:1px solid #ccc; border-radius:6px; }
	button { padding:6px 10px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7; cursor:pointer; }
	.results { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:12px; }
	.card { border:1px solid #e0e0e0; padding:10px; border-radius:6px; background:#fff; }
	.meta { font-size:0.85rem; color:#555; margin-top:6px; }
	.small { font-size:0.85rem; color:#444; }
	.toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
	.form-inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
	textarea { width:100%; min-height:60px; padding:6px; border-radius:6px; border:1px solid #ccc; }
	.footer { margin-top:18px; color:#666; font-size:0.9rem; }
	.count { font-weight:600; }
	.hidden { display:none; }
</style>
</head>
<body>
<div class="container">
	<header>
		<h1>Homebrew ROM Database</h1>
		<div class="toolbar">
			<button id="exportBtn">Export JSON</button>
			<label style="display:inline-flex; gap:8px; align-items:center;">
				<input id="importFile" type="file" accept="application/json,.json" style="display:none;">
				<button id="importBtn" type="button">Import JSON</button>
			</label>
			<button id="resetBtn" title="Reset to sample data">Reset</button>
			<!-- admin controls -->
			<button id="adminBtn">Admin login</button>
			<span id="adminStatus" class="small"></span>
		</div>
	</header>

	<div class="controls">
		<input id="searchInput" type="search" placeholder="Search title, dev, description..." />
		<select id="consoleSelect"><option value="">All consoles</option></select>
		<input id="minYear" type="number" placeholder="Min year" style="width:110px" />
		<input id="maxYear" type="number" placeholder="Max year" style="width:110px" />
		<button id="clearFilters">Clear</button>
	</div>

	<div class="form-inline" style="margin-bottom:8px;">
		<button id="addToggle">Add entry</button>
		<span class="small">Results: <span id="resultCount" class="count">0</span></span>
	</div>

	<!-- Add a file input to the add form -->
	<form id="addForm" class="hidden" onsubmit="return false;">
		<div style="display:flex; gap:8px; flex-wrap:wrap;">
			<input id="title" placeholder="Title (required)" required>
			<input id="console" placeholder="Console (e.g., NES, Genesis) (required)" required>
			<input id="year" type="number" placeholder="Year (required)" style="width:110px" required>
			<input id="developer" placeholder="Developer" >
			<input id="downloadUrl" placeholder="Download URL (optional)" style="min-width:220px;">
			<!-- ROM file now required -->
			<label style="display:inline-flex; align-items:center; gap:8px;">
				<input id="romFile" type="file" accept=".nes,.sfc,.smc,.smd,.gb,.gbc,.gba,.bin,.iso,.zip" title="Upload ROM file (required)" required>
				<span class="small">ROM file (required)</span>
			</label>
			<!-- publish immediately option (admin only) -->
			<!-- hidden for non-admins; updateAdminUI toggles display -->
			<label id="publishNowLabel" style="display:none; align-items:center; gap:8px;">
				<input id="publishNow" type="checkbox" title="Publish immediately (admin only)">
				<span class="small">Publish now</span>
			</label>
		</div>
		<div style="margin-top:8px;">
			<textarea id="description" placeholder="Short description"></textarea>
		</div>
		<div style="margin-top:8px; display:flex; gap:8px;">
			<button id="addSave" type="button">Save</button>
			<button id="addCancel" type="button">Cancel</button>
		</div>
	</form>

	<!-- Pending submissions: admin-only grouped view -->
	<section id="pendingSection" class="results hidden" aria-live="polite" style="margin-top:12px;">
		<div class="small"><strong>Pending submissions</strong></div>
	</section>

	<section id="results" class="results" aria-live="polite"></section>

	<div class="footer">
		<p>Server-backed demo: entries are stored on the server. Use Export/Import to back up or migrate data.</p>
		<div id="debugInfo" class="small" style="margin-top:8px; display:none;"></div>
	</div>
</div>

<script>
	const API_BASE = ''; // same origin
	const DEBUG = new URL(location.href).searchParams.has('debug');
	// element refs + filters
	const el = {
		search: document.getElementById('searchInput'),
		consoleSelect: document.getElementById('consoleSelect'),
		minYear: document.getElementById('minYear'),
		maxYear: document.getElementById('maxYear'),
		results: document.getElementById('results'),
		resultCount: document.getElementById('resultCount'),
		clearFilters: document.getElementById('clearFilters'),
		exportBtn: document.getElementById('exportBtn'),
		importBtn: document.getElementById('importBtn'),
		importFile: document.getElementById('importFile'),
		resetBtn: document.getElementById('resetBtn'),
		addToggle: document.getElementById('addToggle'),
		addForm: document.getElementById('addForm'),
		addSave: document.getElementById('addSave'),
		addCancel: document.getElementById('addCancel'),
		title: document.getElementById('title'),
		consoleInput: document.getElementById('console'),
		year: document.getElementById('year'),
		developer: document.getElementById('developer'),
		downloadUrl: document.getElementById('downloadUrl'),
		description: document.getElementById('description'),
		romFile: document.getElementById('romFile'),
		searchInput: document.getElementById('searchInput')
	};
	let db = []; // always fetched from server
	let filters = { q: '', console: '', minYear: null, maxYear: null };

	// demo admin token (DEMO ONLY). Replace with proper auth in a real app.
	const ADMIN_TOKEN = 'admin-demo-token';

	// helper to attach admin token headers when present (support multiple server schemes)
	function getAuthHeaders() {
		const token = localStorage.getItem('adminToken');
		if (!token) return {};
		// include both header styles (server may expect either)
		return { 'X-Admin-Token': token, 'Authorization': 'Bearer ' + token };
	}

	let isAdmin = false;
	function updateAdminUI() {
		isAdmin = !!localStorage.getItem('adminToken');
		document.getElementById('adminBtn').textContent = isAdmin ? 'Logout admin' : 'Admin login';
		document.getElementById('adminStatus').textContent = isAdmin ? ' (admin)' : '';
		// show/hide publishNow option (admins only)
		el.publishNow = document.getElementById('publishNow');
		const publishLabel = document.getElementById('publishNowLabel');
		if (publishLabel) publishLabel.style.display = isAdmin ? 'inline-flex' : 'none';
		// hide Add toggle for non-admins? We allow submissions from non-admins but they are pending.
		el.addToggle.textContent = isAdmin ? 'Add entry' : 'Submit entry';
		// show/hide pending submissions group
		const pendingSection = document.getElementById('pendingSection');
		if (pendingSection) pendingSection.classList.toggle('hidden', !isAdmin);
	}

	// fetch list from server (server supports filtering)
	async function fetchGames() {
		const params = new URLSearchParams();
		if (filters.q) params.set('q', filters.q);
		if (filters.console) params.set('console', filters.console);
		if (filters.minYear != null) params.set('minYear', String(filters.minYear));
		if (filters.maxYear != null) params.set('maxYear', String(filters.maxYear));
		// request pending entries when admin
		if (isAdmin) params.set('includePending', '1');
		const url = API_BASE + '/api/games' + (params.toString() ? ('?' + params.toString()) : '');
		try {
			const res = await fetch(url, { headers: getAuthHeaders() });
			if (!res.ok) {
				const text = await res.text().catch(()=>null);
				console.error('Fetch games failed', res.status, text);
				alert('Failed to fetch games: ' + (text || res.status));
				db = [];
				applyAndRender();
				return;
			}
			const json = await res.json().catch(()=>null);
			// accept plain arrays or common wrapped shapes: { games: [...], data: [...], ... }
			if (Array.isArray(json)) {
				db = json;
			} else if (json && typeof json === 'object') {
				// prefer data/games, then any first array property
				if (Array.isArray(json.data)) db = json.data;
				else if (Array.isArray(json.games)) db = json.games;
				else {
					const arrProp = Object.keys(json).find(k => Array.isArray(json[k]));
					if (arrProp) db = json[arrProp];
					else {
						console.error('Invalid response from /api/games', json);
						alert('Invalid server response');
						db = [];
					}
				}
			} else {
				console.error('Invalid response from /api/games', json);
				alert('Invalid server response');
				db = [];
			}
			if (DEBUG) {
				console.log('fetched DB:', db);
				const dbg = document.getElementById('debugInfo');
				dbg.style.display = 'block';
				dbg.textContent = `Entries: ${db.length} (approved=${db.filter(e=>e.status==='approved').length}, pending=${db.filter(e=>e.status==='pending').length})`;
			}
			applyAndRender();
		} catch (err) {
			console.error('Network error fetching games', err);
			alert('Network error fetching games: ' + err.message);
			db = [];
			applyAndRender();
		}
	}

	function uniqueConsoles() {
		const set = new Set(db.map(x => x.console).filter(Boolean));
		return Array.from(set).sort();
	}

	// render uses server-provided metadata; file downloads use /api/games/:id/file
	function renderResults() {
		el.results.innerHTML = '';
		// approved entries shown to everyone
		const approved = db.slice().filter(it => it.status === 'approved').sort((a,b)=> (b.year||0)-(a.year||0));
		el.resultCount.textContent = approved.length;
		if (!approved.length) { el.results.innerHTML = '<div class="small">No results.</div>'; }
		approved.forEach(it => {
			const div = document.createElement('div'); div.className = 'card';
			const downloadLink = it.fileName ? `<a href="/api/games/${it.id}/file" download="${encodeURIComponent(it.fileName)}">Download</a>` : (it.downloadUrl ? `<a href="${escapeAttr(it.downloadUrl)}" target="_blank">Download</a>` : '');
			div.innerHTML = `
				<div><strong>${escapeHtml(it.title)}</strong></div>
				<div class="meta">${escapeHtml(it.console)} • ${it.year || 'n/a'} • ${escapeHtml(it.developer || '')}</div>
				<div class="small" style="margin-top:8px">${escapeHtml(it.description || '')}</div>
				<div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
					${downloadLink}
				</div>
			`;
			el.results.appendChild(div);
		});
		// admin-only actions (delete/confirm/reject live in pending group)
		// attach delete handlers for approved items (admins)
		document.querySelectorAll('.delBtn').forEach(b => {
			b.addEventListener('click', async ev => {
				if (!isAdmin) { alert('Only admin can delete entries.'); return; }
				const id = Number(ev.currentTarget.dataset.id);
				if (!confirm('Delete this entry?')) return;
				const res = await fetch(`/api/games/${id}`, { method: 'DELETE', headers: getAuthHeaders() });
				if (!res.ok) { alert('Delete failed'); return; }
				await fetchGames();
			});
		});
		// render pending group (admins only)
		renderPending();
	}

	function renderPending() {
		const pendingEl = document.getElementById('pendingSection');
		if (!pendingEl) return;
		if (!isAdmin) { pendingEl.classList.add('hidden'); return; }
		const pending = db.slice().filter(it => it.status === 'pending').sort((a,b)=> (b.year||0)-(a.year||0));
		if (!pending.length) { pendingEl.innerHTML = '<div class="small">No pending submissions.</div>'; pendingEl.classList.remove('hidden'); return; }
		pendingEl.innerHTML = '';
		pending.forEach(it => {
			const div = document.createElement('div'); div.className = 'card';
			const downloadLink = it.fileName ? `<a href="/api/games/${it.id}/file" download="${encodeURIComponent(it.fileName)}">Download</a>` : (it.downloadUrl ? `<a href="${escapeAttr(it.downloadUrl)}" target="_blank">Download</a>` : '');
			div.innerHTML = `
				<div><strong>${escapeHtml(it.title)}</strong><span class="small" style="margin-left:8px;color:#b66">pending</span></div>
				<div class="meta">${escapeHtml(it.console)} • ${it.year || 'n/a'} • ${escapeHtml(it.developer || '')}</div>
				<div class="small" style="margin-top:8px">${escapeHtml(it.description || '')}</div>
				<div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
					${downloadLink}
					<button data-id="${it.id}" class="confirmBtn">Confirm</button>
					<button data-id="${it.id}" class="rejectBtn">Reject</button>
					<button data-id="${it.id}" class="delBtn">Delete</button>
				</div>
			`;
			pendingEl.appendChild(div);
		});
		// attach pending handlers
		document.querySelectorAll('.confirmBtn').forEach(b => {
			b.addEventListener('click', async ev => {
				if (!isAdmin) { alert('Only admin can confirm entries.'); return; }
				const id = Number(ev.currentTarget.dataset.id);
				const res = await fetch(`/api/games/${id}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', ...getAuthHeaders() }, body: JSON.stringify({ status: 'approved' }) });
				if (!res.ok) { alert('Confirm failed'); return; }
				await fetchGames();
			});
		});
		document.querySelectorAll('.rejectBtn').forEach(b => {
			b.addEventListener('click', async ev => {
				if (!isAdmin) { alert('Only admin can reject entries.'); return; }
				const id = Number(ev.currentTarget.dataset.id);
				if (!confirm('Reject (remove) this pending entry?')) return;
				const res = await fetch(`/api/games/${id}`, { method: 'PATCH', headers: { 'Content-Type': 'application/json', ...getAuthHeaders() }, body: JSON.stringify({ status: 'rejected' }) });
				if (!res.ok) { alert('Reject failed'); return; }
				await fetchGames();
			});
		});
		document.querySelectorAll('#pendingSection .delBtn').forEach(b => {
			b.addEventListener('click', async ev => {
				if (!isAdmin) { alert('Only admin can delete entries.'); return; }
				const id = Number(ev.currentTarget.dataset.id);
				if (!confirm('Delete this entry?')) return;
				const res = await fetch(`/api/games/${id}`, { method: 'DELETE', headers: getAuthHeaders() });
				if (!res.ok) { alert('Delete failed'); return; }
				await fetchGames();
			});
		});
	}

	// utilities
	function escapeHtml(s = '') { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
	function escapeAttr(s=''){ return String(s).replace(/"/g, '%22'); }

	// event wiring (use server endpoints)
	let searchTimer = null;
	el.searchInput.addEventListener('input', () => {
		clearTimeout(searchTimer);
		searchTimer = setTimeout(()=>{ filters.q = el.searchInput.value; fetchGames(); }, 200);
	});
	el.consoleSelect.addEventListener('change', () => { filters.console = el.consoleSelect.value; fetchGames(); });
	el.minYear.addEventListener('change', () => { filters.minYear = el.minYear.value ? Number(el.minYear.value) : null; fetchGames(); });
	el.maxYear.addEventListener('change', () => { filters.maxYear = el.maxYear.value ? Number(el.maxYear.value) : null; fetchGames(); });
	el.clearFilters.addEventListener('click', () => {
		el.searchInput.value = ''; el.consoleSelect.value = ''; el.minYear.value = ''; el.maxYear.value = '';
		filters = { q: '', console: '', minYear: null, maxYear: null };
		fetchGames();
	});

	el.exportBtn.addEventListener('click', async () => {
		const res = await fetch('/api/games/export', { headers: getAuthHeaders() });
		if (!res.ok) { alert('Export failed'); return; }
		const blob = await res.blob();
		const url = URL.createObjectURL(blob);
		const a = document.createElement('a'); a.href = url; a.download = 'homebrew_db.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
	});

	// admin login/logout
	document.getElementById('adminBtn').addEventListener('click', async () => {
		if (isAdmin) {
			localStorage.removeItem('adminToken');
			updateAdminUI();
			await fetchGames();
			return;
		}
		const token = prompt('Enter admin token (demo):');
		if (!token) return;
		if (token === ADMIN_TOKEN) {
			localStorage.setItem('adminToken', token);
			updateAdminUI();
			await fetchGames();
			alert('Admin mode enabled (demo).');
		} else {
			alert('Invalid token.');
		}
	});

	// import JSON file -> POST /api/games/import
	el.importBtn.addEventListener('click', () => el.importFile.click());
	el.importFile.addEventListener('change', async (ev) => {
		const f = ev.target.files && ev.target.files[0];
		if (!f) return;
		try {
			const text = await f.text();
			const parsed = JSON.parse(text);
			if (!Array.isArray(parsed)) throw new Error('Invalid file format');
			const res = await fetch('/api/games/import', { method: 'POST', headers: { 'Content-Type': 'application/json', ...getAuthHeaders() }, body: JSON.stringify(parsed) });
			if (!res.ok) throw new Error('Import failed');
			await fetchGames();
			alert('Imported ' + parsed.length + ' entries.');
		} catch (e) {
			alert('Import failed: ' + e.message);
		}
		ev.target.value = '';
	});

	el.resetBtn.addEventListener('click', async () => {
		if (!confirm('Reset server DB to sample dataset?')) return;
		const res = await fetch('/api/games/reset', { method: 'POST', headers: getAuthHeaders() });
		if (!res.ok) { alert('Reset failed'); return; }
		await fetchGames();
	});

	// Add form: POST /api/games with multipart form-data (rom file optional)
	el.addToggle.addEventListener('click', () => el.addForm.classList.toggle('hidden'));
	el.addCancel.addEventListener('click', () => el.addForm.classList.add('hidden'));
	el.addSave.addEventListener('click', async () => {
		const title = el.title.value.trim(); const c = el.consoleInput.value.trim();
		const y = Number(el.year.value);
		if (!title || !c || !Number.isFinite(y)) { alert('Please fill Title, Console and a numeric Year.'); return; }
		// require ROM file
		const file = el.romFile && el.romFile.files && el.romFile.files[0];
		if (!file) { alert('Please select a ROM file.'); return; }
		// simple client-side safety checks
		const MAX_SIZE = 200 * 1024 * 1024; // 200MB
		if (file.size > MAX_SIZE) { alert('ROM file too large (max 200MB).'); return; }
		const fd = new FormData();
		fd.set('title', title); fd.set('console', c); fd.set('year', String(y));
		fd.set('developer', el.developer.value.trim()); fd.set('description', el.description.value.trim()); fd.set('downloadUrl', el.downloadUrl.value.trim());
		fd.set('rom', file);
		// status: admin can publish immediately; non-admin submissions are pending
		const publishNow = (el.publishNow && el.publishNow.checked) && isAdmin;
		fd.set('status', publishNow ? 'approved' : 'pending');
		el.addSave.disabled = true;
		try {
			const res = await fetch('/api/games', { method: 'POST', body: fd, headers: getAuthHeaders() });
			if (!res.ok) {
				const body = await res.json().catch(()=>({ error: 'Upload failed' }));
				throw new Error(body && body.error ? body.error : 'Add failed');
			}
			el.addForm.reset(); el.addForm.classList.add('hidden');
			await fetchGames();
			if (publishNow) alert('Added and published.');
			else alert('Submitted for review. An administrator must approve it before it appears publicly.');
		} catch (err) {
			alert('Add failed: ' + err.message);
		} finally {
			el.addSave.disabled = false;
		}
	});

	// renderConsoleOptions: use visible entries (admins see pending as well)
	function renderConsoleOptions() {
		const list = (isAdmin ? db : db.filter(x => x.status === 'approved')).map(x => x.console).filter(Boolean);
		const set = new Set(list);
		const arr = Array.from(set).sort();
		el.consoleSelect.innerHTML = '<option value="">All consoles</option>';
		arr.forEach(c => { const opt = document.createElement('option'); opt.value = c; opt.textContent = c; el.consoleSelect.appendChild(opt); });
		const years = (isAdmin ? db : db.filter(x => x.status === 'approved')).map(x => x.year).filter(y => Number.isFinite(y));
		if (years.length) { el.minYear.placeholder = Math.min(...years); el.maxYear.placeholder = Math.max(...years); }
	}

	function applyAndRender() { updateAdminUI(); renderConsoleOptions(); renderResults(); }

	// initial load
	updateAdminUI();
	fetchGames();
</script>
</body>
</html>